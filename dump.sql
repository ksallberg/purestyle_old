-- MySQL dump 10.13  Distrib 5.5.43, for debian-linux-gnu (x86_64)
--
-- Host: eu-cdbr-west-01.cleardb.com    Database: heroku_a223c9262443297
-- ------------------------------------------------------
-- Server version	5.5.40-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `comments`
--

DROP TABLE IF EXISTS `comments`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `comments` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `commenter` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `body` text COLLATE utf8_unicode_ci,
  `post_id` int(11) DEFAULT NULL,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `comments`
--

LOCK TABLES `comments` WRITE;
/*!40000 ALTER TABLE `comments` DISABLE KEYS */;
/*!40000 ALTER TABLE `comments` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `posts`
--

DROP TABLE IF EXISTS `posts`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `posts` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `bgcolor` varchar(7) COLLATE utf8_unicode_ci NOT NULL,
  `title` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `content` text COLLATE utf8_unicode_ci,
  `created_at` datetime DEFAULT NULL,
  `updated_at` datetime DEFAULT NULL,
  `category` varchar(100) COLLATE utf8_unicode_ci NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `posts`
--

LOCK TABLES `posts` WRITE;
/*!40000 ALTER TABLE `posts` DISABLE KEYS */;
INSERT INTO `posts` VALUES (1,'#68e7c8','syntax highlighting','<p class=\"medium\">Checking out the very easy to implement syntax highlighting plugin named <a href=\"http://coderay.rubychan.de\">coderay</a>, a ruby library. I love the ease of installing new plugins to the rails environment.</p>\r\n\r\n<code lang=\"ruby\">\r\nhash = { :water => \'wet\', :fire => \'hot\' }\r\nputs hash[:fire] # Prints:  hot\r\n \r\nhash.each_pair do |key, value| # Or:  hash.each do |key, value|\r\n  puts \"#{key} is #{value}\"\r\nend\r\n \r\n# Prints:  water is wet\r\n#          fire is hot\r\n \r\nhash.delete :water # Deletes :water => \'wet\'\r\nhash.delete_if {|key,value| value==\'hot\'} # Deletes :fire => \'hot\'\r\n\r\ndef testFunction(input1, input2)\r\n   return input1 + input2\r\nend\r\n</code>','2011-04-27 21:54:58','2011-05-29 10:30:42','ruby'),(2,'#442288','binary search tree, js','<p class=\"medium\">A javascript implementation of the Binary Search Tree. It\'s built in a functional manner, where every operation builds a new tree for the affected part of the tree, that probably makes it slow for large trees.\r\n\r\n<br /><br />Usage looks like:\r\n<br />var t1 = new BinarySearchTree( 80 );\r\n<br />t1 = addNode(new BinarySearchTree(23), t1);\r\n<br />t1 = removeNode(23, t1);\r\n</p>\r\n<code lang=\"javascript\">\r\n/**\r\n*   Constructor, add whatever content should\r\n*   be at the root\r\n*/\r\nfunction BinarySearchTree( cont ) {\r\n    \r\n    this.content = cont\r\n    this.leftSub;\r\n    this.rightSub;\r\n    \r\n    this.toString = function() {\r\n        \r\n        return preOrderTraverse( 0, this );\r\n    }\r\n}\r\n\r\n/**\r\n*   Add a node to a tree and get a newly constructed tree back\r\n*/\r\nfunction addNode( treetoAdd, tree ) {\r\n    \r\n    //If what we want to add is already in there, \r\n    //just return the tree\r\n    if( treetoAdd.content == tree.content ) {\r\n        \r\n        return tree;\r\n        \r\n    //If what we want to add is larger than the content at the\r\n    //node we are currently at, go into the right sub tree\r\n    } else if ( treetoAdd.content > tree.content ) {\r\n        \r\n        //If the right sub tree is not empty, then go into it\r\n        if( tree.rightSub != null ) {\r\n            \r\n            tree.rightSub = addNode( treetoAdd, tree.rightSub );\r\n        \r\n        //If it\'s empty, that\'s the spot where toAdd should \r\n        //be added!\r\n        } else {\r\n            \r\n            tree.rightSub = treetoAdd;\r\n        }\r\n    \r\n    //If what we want to add is smaller than the content at the\r\n    //node we are at\r\n    } else {\r\n        \r\n        //If the left sub tree is not empty, go there!\r\n        if( tree.leftSub != null ) {\r\n            \r\n            tree.leftSub = addNode( treetoAdd, tree.leftSub )\r\n            \r\n        //Else, add toAdd into that empty spot\r\n        } else {\r\n            \r\n            tree.leftSub = treetoAdd;\r\n        }\r\n    }\r\n    \r\n    //all the returns from the above tree modifications here\r\n    return tree;\r\n}\r\n\r\n/**\r\n*   Remove a node in a tree and get a newly constructed tree back\r\n*/\r\nfunction removeNode( toRemove, tree ) {\r\n    \r\n    //If what you want to remove is the node we are at right now\r\n    if( toRemove == tree.content ) {\r\n        \r\n        //If both sub trees are null, just set the node to null\r\n        if( tree.leftSub == null && tree.rightSub == null )\r\n            return null;\r\n        \r\n        //return newRightSu\r\n        if( tree.rightSub != null && tree.leftSub != null )\r\n            return addNode( tree.leftSub, tree.rightSub );\r\n        \r\n        //If just the left sub tree is null, remove this node and \r\n        //replace it with the right sub tree\r\n        if( tree.leftSub == null )\r\n            return tree.rightSub\r\n        \r\n        //If just the right sub is null, remove this node and\r\n        //replace it with the left sub tree\r\n        if( tree.rightSub == null )\r\n            return tree.leftSub\r\n        \r\n        return tree;\r\n        \r\n    //The element to remove is in the right sub tree\r\n    } else if ( toRemove > tree.content ) {\r\n        \r\n        //If we have a right sub tree, try to remove the element \r\n        //from there\r\n        if( tree.rightSub != null )\r\n            tree.rightSub = removeNode( toRemove, tree.rightSub );\r\n    \r\n    //The element to remove is in the left sub tree\r\n    } else {\r\n        \r\n        //If the element is in the right\r\n        if( tree.leftSub != null )\r\n            tree.leftSub = removeNode( toRemove, tree.leftSub );\r\n    }\r\n    \r\n    //If the element isn\'t in the tree, also the returns from 2 \r\n    //if cases above\r\n    return tree;\r\n}\r\n\r\n/**\r\n*   Search for an element, return null if it\'s not in the tree\r\n*/\r\nfunction get( elem, tree ) {\r\n    \r\n    //If the content we are looking for is in this node\r\n    if( elem == tree.content ) {\r\n        \r\n        return tree.content;\r\n        \r\n    //If what we want to get is larger than the content at the\r\n    //node we are currently at, go into the right sub tree\r\n    } else if ( elem > tree.content ) {\r\n        \r\n        //If the right sub tree is not empty, then go into it\r\n        if( tree.rightSub != null ) {\r\n            \r\n            return get( elem, tree.rightSub );\r\n        \r\n        //elem isn\'t in the tree\r\n        } else {\r\n            \r\n            return null;\r\n        }\r\n    \r\n    //If what we want to get is smaller than the content at the\r\n    //node we are at\r\n    } else {\r\n        \r\n        //If the left sub tree is not empty, go there!\r\n        if( tree.leftSub != null ) {\r\n            \r\n            return get( elem, tree.leftSub )\r\n            \r\n        //elem isn\'t in the tree\r\n        } else {\r\n            \r\n            return null;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n*   Traverse through the tree, pre order\r\n*   ()\r\n*/\r\nfunction preOrderTraverse( levels, tree ) {\r\n    \r\n    var before = \"<br>\"\r\n    \r\n    for( i  = 0; i < levels; i ++)\r\n        for( j  = 0; j < 12; j ++)\r\n            before += \"&nbsp;\"\r\n    \r\n    if( tree == null )\r\n        return before + \"null\"\r\n        \r\n    return  before + tree.content + \r\n            preOrderTraverse( levels + 1, tree.leftSub ) + \r\n            preOrderTraverse( levels + 1, tree.rightSub )\r\n}\r\n</code>','2011-05-20 22:30:10','2013-01-04 21:16:21','data_structures,javascript,functional'),(3,'#f4e74d','BST < haskell','<p class=\"medium\">A data type for creating a binary tree, and some functions for inserting, removing and searching for nodes.<br/><br/>\r\n\r\nUsage: testTree = foldr addNode Empty [10,20,12,33,44,0] (Add some integers to the tree)<br/>\r\ntestTree2 = foldr removeNode testTree [33,44,0] (Remove some from the first tree)\r\n</p>\r\n<code lang=\"sql\">\r\n-- Data type for representing a tree\r\ndata BinTree a = Empty | Node a (BinTree a) (BinTree a)\r\n   deriving (Eq, Show, Read)\r\n\r\n-- Add a node to a tree\r\naddNode :: Eq a => Ord a => a -> BinTree a -> BinTree a\r\naddNode toAdd Empty              = (Node toAdd Empty Empty) -- add something in this spot\r\naddNode toAdd tree@(Node x l r) | toAdd == x = tree -- toAdd is already in the tree\r\n                                | toAdd > x  = Node x l (addNode toAdd r)\r\n                                | otherwise  = Node x (addNode toAdd l) r\r\n\r\n-- Add a tree to a tree\r\naddTree :: Ord a => BinTree a -> BinTree a -> BinTree a\r\naddTree Empty t2        = t2\r\naddTree (Node x l r) t2 = addTree r (addTree l (addNode x t2))\r\n\r\n-- Remove a node from a tree\r\nremoveNode :: Ord a => a -> BinTree a -> BinTree a\r\nremoveNode toRem Empty = Empty\r\nremoveNode toRem (Node x l r) | toRem == x = addTree l r\r\n                              | toRem > x  = Node x l (removeNode toRem r)\r\n                              | otherwise  = Node x (removeNode toRem l) r\r\n\r\n-- Search for an element in the tree\r\nget :: Ord a => a -> BinTree a -> Maybe a\r\nget elem Empty = Nothing\r\nget elem (Node x l r) | elem == x = Just x\r\n                      | elem > x  = get elem r\r\n                      | otherwise = get elem l\r\n\r\n-- Get the yield of a tree\r\npreOrderTraverse :: BinTree a -> [a]\r\npreOrderTraverse Empty = []\r\npreOrderTraverse tree@(Node x l r) = x : (preOrderTraverse l ++ preOrderTraverse r)\r\n</code>','2011-05-28 21:11:14','2013-01-04 21:13:51','functional,data_structures'),(4,'#fa513c','junit - custom error messages','<code lang=\"java\">\r\nTypeSafeMatcher<Double> match = new TypeSafeMatcher<Double>() {\r\n\r\n    @Override\r\n    public void describeTo(Description arg0) {\r\n        // TODO Auto-generated method stub\r\n        \r\n    }\r\n\r\n    @Override\r\n    public boolean matchesSafely(Double arg0) {\r\n        \r\n        System.out.println( arg0 );\r\n        \r\n        //test that something is <=100\r\n        return !( arg0 > 100 );\r\n    }\r\n};\r\n    \r\nAssert.assertThat( \"Oh no it\'s > 100!\", 100.34, match );\r\n</code>','2011-11-10 18:39:30','2011-11-10 18:46:25','testing,java'),(5,'#c1cddb','scala tricks','<code lang=\"java\">\r\npackage test\r\n\r\nobject TestaLite {\r\n    \r\n    def main( args : Array[String] ) {\r\n        \r\n        //Map fibonacci\r\n        val nums = Array(1,2,3,4,5,6,7,8,9,10)\r\n        val nums2 = nums map { fib }\r\n        println( nums2.deepToString() )\r\n        \r\n        //Filter\r\n        val nums3 = nums filter { filt }\r\n        println( nums3.deepToString() )\r\n        \r\n        //List comprehension with filter\r\n        for( i <- Iterator.range(0, 20) if i % 2 == 0 )\r\n            println( i )\r\n    }\r\n    \r\n    //Recursive fibonacci\r\n    def fib( i : Int ) : Int = {\r\n        \r\n        i match {\r\n            \r\n            case 0 => 0\r\n            case 1 => 1\r\n            case _ => fib( i - 2 ) + fib( i - 1 )\r\n        }\r\n    }\r\n    \r\n    //Keep only 2\'s\r\n    def filt( i : Int ) : Boolean = {\r\n        \r\n        i match {\r\n            \r\n            case 2 => true\r\n            case _ => false\r\n        }\r\n    }   \r\n}\r\n</code>','2011-11-10 19:01:22','2012-01-03 19:22:55','functional,scala'),(6,'#ff5b45','net present value','<p class=\"medium\">The right tool for the job. Sometimes you find really nice applications of a language you already know - that you didn\'t think of when learning it. Like when I had to calculate \"net present value\" for a couple of investments. The code is pretty much what the formula looks like expressed mathematically.</p>\r\n\r\n<code lang=\"sql\">\r\n--Calculate npv\r\nnpv :: Float -> Float -> Float -> Float -> Float -> Integer -> Float\r\nnpv initial rf b cashflow salvage years\r\n   = (sumNpv (capm rf b) cashflow years)\r\n   + (salvage / (capm rf b)^years) - initial\r\n\r\n-- Calculate the npv sum recursively\r\nsumNpv :: Float -> Float -> Integer -> Float\r\nsumNpv cap cashflow 0 = 0\r\nsumNpv cap cashflow year\r\n   = (cashflow / (cap^year)) \r\n   + (sumNpv cap cashflow (year-1))\r\n\r\n-- Calculate capm given risk free interest and beta\r\ncapm :: Float -> Float -> Float\r\ncapm rf b = ((rf + b * ( (erM rf b) - rf )) / 100)+1\r\n\r\nerM :: Float -> Float -> Float\r\nerM rf b = rf + rf * b\r\n</code>','2011-11-26 23:13:44','2012-02-18 14:40:05','functional'),(7,'#000000','DD Min','<p class=\"medium\">\r\nAn implementation of the DD Min algorithm in Haskell. It\'s used for finding the shortest local failing test input in a longer failing input.\r\n</p>\r\n<p class=\"medium\">\r\nFor instance, if having two e\'s in a string is considered an error, and a faulty string \"hmmehmmmmmexxx\" is given. This algorithm shortens the faulty input to \"ee\":\r\n</p>\r\n<p class=\"medium\">\r\nddMin \"hmmehmmmmmexxx\" testFor2E\r\n</p>\r\n\r\n<code lang=\"sql\">\r\nimport Data.List\r\n\r\ndata Result = Pass | Fail | Unresolved\r\n   deriving (Show, Eq)\r\n\r\nddMin :: String -> (String->Bool) -> String\r\nddMin input testFor = ddMin\' input 2 testFor\r\n\r\n--Pseudo code for the ddmin\' function\r\n--ddmin\' (c\'x,n)\r\n--ddmin\' c\'x                    --if |c\'x| == 1\r\n--ddmin\' (c\'x \\ci, max(n-1,2))  --else if EXIST i in {1...n} x test (c\'x \\ ci) == x\r\n--ddmin\' (c\'x, min(2n, |c\'x|))  --else if n < |c\'x|\r\n--ddmin\' c\'x                    --otherwise\r\n\r\n--DD Min specific functions:\r\nddMin\' :: String -> Int -> (String->Bool) -> String\r\nddMin\' input chunks testFor\r\n   | length input == 1        = input\r\n   | length failedCases > 0   = ddMin\' (head failedCases) (max (chunks-1) 2) testFor\r\n   | chunks < length input    = ddMin\' input (min (2*chunks) (length input)) testFor\r\n   | otherwise                = input\r\n   where \r\n      failedCases = [input `removeChunk` x |\r\n                     x <- subsets, test testFor (input `removeChunk` x) == Fail]\r\n      subsets     = createSubset chunks input\r\n\r\ncreateSubset :: Int -> String -> [String]\r\ncreateSubset chunks str\r\n   | chunks > length str = error \"NOOO!\"\r\n   | otherwise\r\n   = chunk (ceiling $ intToFloat (length str) / intToFloat(chunks)) str\r\n\r\nchunk :: Int -> String -> [String]\r\nchunk len str | len > length str && str /= \"\" = [str]\r\n              | len > length str              = []\r\n              | otherwise                     = fst spl : chunk len (snd spl)\r\n              where spl                       = splitAt len str\r\n\r\nintToFloat :: Int -> Float\r\nintToFloat n = fromInteger (toInteger n)\r\n\r\nremoveChunk :: String -> String -> String\r\nremoveChunk s find = removeChunk\' s find \"\" False\r\n\r\nremoveChunk\' :: Eq a => [a] -> [a] -> [a] -> Bool -> [a]\r\nremoveChunk\' [] _ _      isRemoved = []\r\nremoveChunk\' s find repl isRemoved =\r\n    if (take (length find) s == find) && (isRemoved == False)\r\n        then repl ++ (removeChunk\' (drop (length find) s) find repl True)\r\n        else [head s] ++ (removeChunk\' (tail s) find repl isRemoved)\r\n\r\n--Test specific functions:\r\ntest :: (String->Bool) -> String -> Result\r\ntest function str | res == True  = Fail\r\n                  | res == False = Pass\r\n                  where res = function str\r\n\r\ntestFor2E :: String -> Bool\r\ntestFor2E str = ((count \'e\' str) >= 2)\r\n\r\ntestFor4A :: String -> Bool\r\ntestFor4A str = (count \'a\' str) >= 4\r\n\r\n-- Count the number of a char in a string\r\ncount :: Char -> String -> Int\r\ncount checkfor [] = 0\r\ncount checkfor (x:xs) | x == checkfor = 1 + count checkfor xs\r\ncount checkfor (x:xs) = count checkfor xs\r\n</code>','2011-12-05 16:28:31','2012-04-09 12:09:07','functional,testing'),(8,'#fc9037','substr C','<p class=\"medium\">\r\n\r\nNote to self:<br>\r\nSubstr in C:\r\n\r\n<code lang=\"C\">\r\nchar word;\r\nchar *string;\r\n\r\nwhile( *string != \'\\0\' ) {\r\n\r\n      char *to;\r\n      to = strndup( string, 1 );\r\n\r\n      printf( \"%s, \\n\", to );\r\n      string ++;\r\n}\r\n</code>\r\n</p>','2012-02-08 17:12:15','2012-08-31 20:37:25','C'),(9,'#556175','wordsnake','<p class=\"medium\">I created a program to find the longest word snake (the following word\'s starting letter is the previous word\'s last letter) in a given set of words. Output: swag, greta, apple. Inject in ruby works the same way as fold in Haskell.</class>\r\n\r\n<code lang=\"ruby\">\r\ndef fixCombinations( array )\r\n  array.inject([]) { \r\n    |memo,word| memo << array.permutation(memo.length+1).to_a }.inject([]) { \r\n    |mem,wor| mem + wor }\r\nend\r\n\r\ndef isWordSnake( words )\r\n  words.inject() { \r\n    |memo,word| memo = memo[-1,1] != word[0,1] ? \"\" : word } == words[-1,1].to_s\r\nend\r\n\r\ndef getLongestSnake( words )\r\n  fixCombinations( words ).find_all{ |word| isWordSnake(word) }.max{ \r\n    |a,b| a.length <=> b.length }\r\nend\r\n\r\nputs getLongestSnake( [\"greta\", \"swag\", \"volkswagen\", \"toyota\", \"vvv\", \"apple\"] )\r\n</code>','2012-04-06 12:48:04','2013-01-05 14:00:28','functional,ruby'),(10,'#b2e400','beatr','<p class=\"medium\">I spent this summer living in Berlin. While there I created beatr, an Android app that contains a few instruments that can be put together to create some simple beats. New updates will come to make this app more usable.\r\n<br/><br/>\r\n<a href=\"https://play.google.com/store/apps/details?id=se.purestyle.beatr\">https://play.google.com/store/apps/details?id=se.purestyle.beatr</a>\r\n<br/><br/>\r\nI use the software synthesizer <a href=\"http://puredata.info/docs/developer/BuildingPdForAndroid/\">Pure Data</a>. Pure Data is ported for many languages and platforms, including Android using NDK (native dev kit).\r\n<br/><br/>\r\nFont by <a href=\"lufthamn.com\">lufthamn</a>\r\n</p>','2012-08-31 20:55:23','2013-01-04 21:28:02','java,android,sound'),(11,'#653e65','gcc linked libraries','<p class=\"medium\">How to see where gcc loads linked C libaries from:<br/>\r\n`gcc -print-prog-name=cc1` -v\r\n<br/><br/>\r\ngcc -lSOMETHING means load libary \"libSOMETHING\" and not load executable SOMETHING...\r\n<br/><br/>\r\ngcc -lexif loads C library exif.<br/>\r\ngcc -I (capital i) \"some library\" includes it\r\n</p>','2012-10-14 13:20:33','2014-02-26 20:05:57','C'),(12,'#FF5333','monadic binding haskell','<p class=\"medium\">\r\nRemoving the syntactic sugar in the do notation...\r\n</p>\r\n<code lang=\"sql\">\r\ndo p <- (putStrLn \"hey\")\r\n        (putStrLn \"yo\" )\r\n</code>\r\n<p class=\"medium\">\r\n<strong>equals to</strong><br/>\r\n<br/>\r\n(putStrLn \"hey\") >>= \\p -> (putStrLn \"yo\")<br/>\r\n<br/>\r\n—————————————————<br/>\r\n</p>\r\n<code lang=\"sql\">\r\ndo (putStrLn \"hey\")\r\n   (putStrLn \"yo\" )\r\n</code>\r\n<p class=\"medium\">\r\n<strong>equals to</strong><br/>\r\n<br/>\r\n(putStrLn \"hey\") >> (putStrLn \"yo\")<br/>\r\n</p>','2012-10-30 22:53:32','2012-10-30 23:05:39','functional'),(13,'#572223','maybe monad implementation','<p class=\"medium\">\r\nI implemented the Maybe monad in haskell.\r\n</p>\r\n<code lang=\"sql\">\r\n{-\r\n   Own implementation of the Maybe monad\r\n   I just with Strings right now\r\n-}\r\n\r\nimport Control.Monad\r\nimport Data.Maybe\r\n\r\n-- data type to wrap the content\r\ndata MyMaybe a = MyNothing | MyJust a\r\n   deriving Show\r\n\r\n-- monad declaration\r\n\r\ninstance Monad MyMaybe where\r\n   return x         = MyJust x\r\n   MyNothing  >>= f = MyNothing\r\n   (MyJust x) >>= f = f x\r\n   fail _           = MyNothing\r\n\r\n-- Test the bind >>== of Nothing\r\n-- using the monad with the do notation\r\ntestBind :: MyMaybe String\r\ntestBind = do MyNothing\r\n              MyNothing\r\n              MyNothing\r\n              MyNothing\r\n\r\n-- Test of binding (>>=) x to\r\n-- \"ha\" and then giving it back \r\n-- at the last line while first\r\n-- creating \"ho\"\r\ntestBind2 :: MyMaybe String\r\ntestBind2 = do (MyJust \"yo!\")\r\n               x <- return (MyJust \"bind\")\r\n               (MyJust \"do not bind\")\r\n               x\r\n\r\n-- get the just part of mymaybe\r\ngetMyJust :: MyMaybe String\r\ngetMyJust = return \"hi!\"\r\n\r\n-- get the nothing part of mymaybe\r\ngetMyNothing :: MyMaybe String\r\ngetMyNothing = MyNothing\r\n\r\n-- get the just part of maybe\r\ngetJust :: Maybe String\r\ngetJust = return \"hello\"\r\n\r\n-- get the nothing part of maybe\r\ngetNothing :: Maybe String\r\ngetNothing = Nothing\r\n\r\n-- like fromJust \r\ngetBack :: MyMaybe String -> String\r\ngetBack MyNothing  = \"nothing\"\r\ngetBack (MyJust x) = x\r\n\r\n-- run some tests\r\nmain :: IO ()\r\nmain = do putStrLn \"get Just from my monad:\"\r\n          putStrLn $ getBack getMyJust\r\n          putStrLn \"get Just from the Maybe monad\"\r\n          putStrLn $ fromJust getJust\r\n          putStrLn \"get Nothing from my monad\"\r\n          putStrLn $ show getMyNothing\r\n          putStrLn \"testing the bind1 function\"\r\n          putStrLn $ show testBind\r\n          putStrLn \"testing the bind2 function\"\r\n          putStrLn $ getBack testBind2\r\n</code>','2013-01-04 21:12:39','2013-01-04 21:15:15','functional'),(14,'#FF5333','state monad implementation','<code lang=\"sql\">\r\nimport Control.Monad\r\nimport Control.Monad.State\r\n\r\n---- :::: Native state monad :::: ----\r\n\r\n-- Run the native State monad with a \r\n-- simple integer value\r\nrun :: Int -> IO ()\r\nrun input = do putStrLn \"Let\'s use states!\"\r\n               let (a,s) = runState doSomething input\r\n               putStrLn $ \"Return value: \" ++ show a\r\n               putStrLn $ \"Final state: \" ++ show s\r\n\r\n-- Increment the value of the native\r\n-- state monad\r\ndoSomething :: State Int ()\r\ndoSomething = do i <- get\r\n                 let new = i + 10\r\n                 put new\r\n                 return ()\r\n\r\n---- :::: Own state monad implementation :::: ----\r\n\r\nnewtype MyState s a = MyState {myRunState :: s -> (a,s)}\r\n\r\ninstance Monad (MyState s) where\r\n   return x           = MyState (\\s -> (x,s))\r\n   (MyState ol) >>= f = MyState $ \\s -> let (n, new) = ol s\r\n                                            (MyState g) = f n\r\n                                        in  g new\r\n   fail x             = error \"error hehe\"\r\n\r\nmyGet :: MyState a a\r\nmyGet = MyState $ \\s -> (s,s)\r\n\r\nmyPut :: Int -> MyState Int ()\r\nmyPut input = MyState $ \\s -> ((),input)\r\n\r\nmyDoSomething :: MyState Int ()\r\nmyDoSomething = do i <- myGet\r\n                   let new = i + 10\r\n                   myPut new\r\n                   return ()\r\n\r\nmyRun :: Int -> IO ()\r\nmyRun input = do putStrLn \"Let\'s use my state!\"\r\n                 let (a,s) = myRunState myDoSomething input\r\n                 putStrLn $ \"My return value: \" ++ show a\r\n                 putStrLn $ \"My final state: \" ++ show s\r\n</code>','2013-01-05 19:46:55','2013-01-14 19:43:13','functional'),(15,'#CDE472','file scanner erlang','<p class=\"medium\">A file searching program, printing all files matching a given pattern to the terminal. It works concurrently with message passing (using a given number of spawned processes).</p>\r\n\r\n<code lang=\"sql\">\r\n-module(scanner).\r\n-export([main/3]).\r\n\r\n% usage: scanner:main(files,X,Y).\r\n%    where X is amount of processes\r\n%          Y us pattern like \".java\"\r\n% populate a process with \r\nmain(Path,Processes,Pattern) ->\r\n   % create the process holding directories\r\n   % give it a list of directories to scan\r\n   % a list scanned files matching\r\n   % and a variable that knows when all dirs are entered into list 1\r\n   Workers = [spawn(fun() -> worker(Pattern) end) ||\r\n                          _ <- lists:seq(1,Processes)],\r\n   Dirs = spawn(fun() -> dir_list([],Workers,[]) end),\r\n   scan(Dirs,Path),\r\n   % tell all the DirActor that all directories are in there now\r\n   Dirs ! {all_dirs_read},\r\n   io:fwrite(\"\").\r\n\r\n% scan through the given path for directories\r\n% send all directories to the DirActor which will \r\n% distribute them to workers\r\nscan(DirActor,Path) ->\r\n   case filelib:is_dir(Path) of\r\n      false -> [];\r\n      true  -> {ok,Listing} = file:list_dir(Path),\r\n               DirActor ! {add_dir,Path},\r\n               [scan(DirActor,filename:join(Path,Name)) || Name <- Listing]\r\n   end.\r\n\r\n% a function that will be run by a process that\r\ndir_list(Matches,Workers,DeadWorkers) ->\r\n   receive\r\n      {dead,DeadW} ->\r\n         case DeadW == length(Workers) of\r\n            true ->\r\n               print_all(Matches);\r\n            false ->\r\n               ok\r\n         end,\r\n         dir_list(Matches,Workers,DeadW);\r\n      {add_dir,Dir} ->\r\n         % get a random worker\r\n         RandWorker = lists:nth(random:uniform(length(Workers)),Workers),\r\n         RandWorker ! {folder,Dir,self()},\r\n         dir_list(Matches,Workers,DeadWorkers);\r\n      {add_file,File} ->\r\n         dir_list(Matches++[File],Workers,DeadWorkers);\r\n      {all_dirs_read} ->\r\n         % tell all workers they can die\r\n         kill_workers(Workers,self(),0),\r\n         dir_list(Matches,Workers,DeadWorkers)\r\n   end.\r\n\r\n% recursively kill all workers\r\nkill_workers([],_,_) -> ok;\r\nkill_workers([X|Xs],Caller,Dead) ->\r\n   X ! {die,Caller,Dead},\r\n   kill_workers(Xs,Caller,Dead+1).\r\n\r\n% the function that a worker process will be running\r\nworker(Pattern) ->\r\n   receive\r\n      {folder,Folder,Caller} ->\r\n         {ok,FolderContent} = file:list_dir(Folder),\r\n         Files = [Folder ++ File || File <- FolderContent,\r\n                          (filelib:is_dir(File) == false) and\r\n                          wrap_regexp(File,Pattern) == true\r\n                 ],\r\n         send_files(Files,Caller),\r\n         worker(Pattern);\r\n      {die,From,DeadWorkers} ->\r\n         From ! {dead,DeadWorkers+1}\r\n   end.\r\n\r\n% send a list of file names to \r\n% a given process\r\nsend_files([],_) -> ok;\r\nsend_files([X|Xs],SendTo) ->\r\n   SendTo ! {add_file,X},\r\n   send_files(Xs,SendTo).\r\n\r\n% perform the reg exp checkup and \r\n% return true or false\r\nwrap_regexp(Str,Exp) ->\r\n   {ok,MP} = re:compile(Exp),\r\n   case re:run(Str,MP) of\r\n      nomatch -> false;\r\n      _ -> true\r\n   end.\r\n\r\n% debug print everything in a list\r\nprint_all([]) -> ok;\r\nprint_all([X|Xs]) -> io:fwrite(X),\r\n                     io:fwrite(\"\\n\"),\r\n                     print_all(Xs).\r\n</code>','2013-01-14 19:41:16','2013-01-17 09:37:23','functional');
/*!40000 ALTER TABLE `posts` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `schema_migrations`
--

DROP TABLE IF EXISTS `schema_migrations`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `schema_migrations` (
  `version` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  UNIQUE KEY `unique_schema_migrations` (`version`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `schema_migrations`
--

LOCK TABLES `schema_migrations` WRITE;
/*!40000 ALTER TABLE `schema_migrations` DISABLE KEYS */;
INSERT INTO `schema_migrations` VALUES ('20110320173607'),('20110320193049'),('20110421182155'),('20110423175129');
/*!40000 ALTER TABLE `schema_migrations` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `slugs`
--

DROP TABLE IF EXISTS `slugs`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `slugs` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `sluggable_id` int(11) DEFAULT NULL,
  `sequence` int(11) NOT NULL DEFAULT '1',
  `sluggable_type` varchar(40) COLLATE utf8_unicode_ci DEFAULT NULL,
  `scope` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,
  `created_at` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `index_slugs_on_n_s_s_and_s` (`name`,`sluggable_type`,`sequence`,`scope`),
  KEY `index_slugs_on_sluggable_id` (`sluggable_id`)
) ENGINE=InnoDB AUTO_INCREMENT=19 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `slugs`
--

LOCK TABLES `slugs` WRITE;
/*!40000 ALTER TABLE `slugs` DISABLE KEYS */;
INSERT INTO `slugs` VALUES (2,'syntax-highlighting',1,1,'Post',NULL,'2011-04-28 11:07:41'),(3,'binary-search-tree-js',2,1,'Post',NULL,'2011-05-20 22:30:10'),(4,'bst-haskell',3,1,'Post',NULL,'2011-05-28 21:11:14'),(5,'junit-custom-error-messages',4,1,'Post',NULL,'2011-11-10 18:39:30'),(8,'scala-tricks',5,1,'Post',NULL,'2011-11-10 19:01:22'),(9,'net-present-value',6,1,'Post',NULL,'2011-11-26 23:13:44'),(10,'dd-min',7,1,'Post',NULL,'2011-12-05 16:28:31'),(11,'substr-c',8,1,'Post',NULL,'2012-02-08 17:12:15'),(12,'wordsnake',9,1,'Post',NULL,'2012-04-06 12:48:04'),(13,'beatr',10,1,'Post',NULL,'2012-08-31 20:55:23'),(14,'gcc-linked-libraries',11,1,'Post',NULL,'2012-10-14 13:20:33'),(15,'monadic-binding-haskell',12,1,'Post',NULL,'2012-10-30 22:53:32'),(16,'maybe-monad-implementation',13,1,'Post',NULL,'2013-01-04 21:12:39'),(17,'state-monad-implementation',14,1,'Post',NULL,'2013-01-05 19:46:55'),(18,'file-scanner-erlang',15,1,'Post',NULL,'2013-01-14 19:41:16');
/*!40000 ALTER TABLE `slugs` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2015-05-24 16:23:29
